# cogs/command_manager.py

import discord
from discord import app_commands
from discord.ext import commands
import logging
from typing import Optional, List
from utils.command_registry import CommandRegistry

logger = logging.getLogger('command_manager')

def is_bot_owner():
    async def predicate(interaction: discord.Interaction) -> bool:
        return await interaction.client.is_owner(interaction.user)
    return app_commands.check(predicate)

class CommandManagerCog(commands.Cog):
    """Cog for managing slash commands and command registry."""
    
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        if not hasattr(bot, 'command_registry'):
            bot.command_registry = CommandRegistry(bot)
        self.registry = bot.command_registry
        
    @app_commands.command(
        name="sync_commands",
        description="Manually sync all slash commands. This makes new commands available."
    )
    @is_bot_owner()
    async def sync_commands(self, interaction: discord.Interaction):
        """Sync all slash commands."""
        await interaction.response.defer(ephemeral=True)
        
        try:
            # Make all commands global first
            self.registry.make_all_commands_global()
            
            # Sync commands
            num_synced, errors = await self.registry.sync_commands()
            
            if errors:
                await interaction.followup.send(
                    f"❌ Errors occurred during command sync:\n" + "\n".join(errors),
                    ephemeral=True
                )
            else:
                await interaction.followup.send(
                    f"✅ Successfully synced {num_synced} commands!\n"
                    "Note: It may take a few minutes for all commands to appear.",
                    ephemeral=True
                )
                
        except Exception as e:
            logger.error(f"Error in sync_commands: {e}")
            await interaction.followup.send(
                f"❌ An error occurred: {str(e)}",
                ephemeral=True
            )

    @app_commands.command(
        name="list_commands",
        description="List all registered slash commands."
    )
    @is_bot_owner()
    async def list_commands(self, interaction: discord.Interaction):
        """List all registered commands."""
        await interaction.response.defer(ephemeral=True)
        
        try:
            commands = self.registry.get_all_commands()
            if not commands:
                await interaction.followup.send(
                    "No commands registered yet.",
                    ephemeral=True
                )
                return
                
            # Create an embed to show commands
            embed = discord.Embed(
                title="Registered Commands",
                description=f"Found {len(commands)} registered commands",
                color=discord.Color.blue()
            )
            
            # Group commands by cog
            cogs = {}
            for cmd_id, cmd_info in commands.items():
                cog_name = cmd_info["cog"]
                if cog_name not in cogs:
                    cogs[cog_name] = []
                cogs[cog_name].append(cmd_info)
            
            # Add each cog as a field
            for cog_name, cmds in cogs.items():
                cmd_list = []
                for cmd in cmds:
                    # Skip subcommands (they'll be shown with their parent)
                    if "parent" in cmd:
                        continue
                    
                    # Format command info
                    cmd_text = f"`/{cmd['name']}`"
                    if cmd.get("is_group", False):
                        subcmds = [c for c in cmds if c.get("parent") == cmd["name"]]
                        if subcmds:
                            cmd_text += " (with subcommands: "
                            cmd_text += ", ".join(f"`{s['name']}`" for s in subcmds)
                            cmd_text += ")"
                    
                    # Add sync status
                    if cmd.get("synced", False):
                        cmd_text += " ✅"
                    else:
                        cmd_text += " ❌"
                        
                    cmd_list.append(cmd_text)
                
                # Add field for this cog if it has commands
                if cmd_list:
                    embed.add_field(
                        name=f"{cog_name} ({len(cmd_list)} commands)",
                        value="\n".join(cmd_list),
                        inline=False
                    )
            
            # Add sync status information
            global_status = self.registry.get_sync_status()
            if global_status.get("last_sync"):
                import datetime
                sync_time = datetime.datetime.fromtimestamp(global_status["last_sync"]).strftime("%Y-%m-%d %H:%M:%S")
                embed.set_footer(text=f"Last global sync: {sync_time} ({global_status['commands_synced']} commands)")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
                
        except Exception as e:
            logger.error(f"Error in list_commands: {e}")
            await interaction.followup.send(
                f"❌ An error occurred: {str(e)}",
                ephemeral=True
            )

    @app_commands.command(
        name="clear_commands",
        description="Clear all slash commands. Use with caution!"
    )
    @is_bot_owner()
    async def clear_commands(self, interaction: discord.Interaction):
        """Clear all registered commands from Discord."""
        await interaction.response.defer(ephemeral=True)
        
        try:
            # Confirm this destructive action
            confirm_view = ConfirmView()
            await interaction.followup.send(
                "⚠️ **Warning**: This will remove all slash commands from Discord. "
                "You will need to run `/sync_commands` to restore them.\n\n"
                "Are you sure you want to continue?",
                view=confirm_view,
                ephemeral=True
            )
            
            # Wait for confirmation
            await confirm_view.wait()
            if not confirm_view.value:
                await interaction.followup.send("Command clearing cancelled.", ephemeral=True)
                return
            
            # Clear commands
            self.bot.tree.clear_commands(guild=None)
            await self.bot.tree.sync()
            
            # Update registry
            for cmd_id in self.registry.commands:
                self.registry.commands[cmd_id]["synced"] = False
            self.registry.save_registry()
            
            await interaction.followup.send(
                "✅ All commands have been cleared from Discord.",
                ephemeral=True
            )
                
        except Exception as e:
            logger.error(f"Error in clear_commands: {e}")
            await interaction.followup.send(
                f"❌ An error occurred: {str(e)}",
                ephemeral=True
            )

class ConfirmView(discord.ui.View):
    """Simple confirmation view with Yes/No buttons."""
    
    def __init__(self):
        super().__init__(timeout=30)
        self.value = None
        
    @discord.ui.button(label="Yes", style=discord.ButtonStyle.danger)
    async def yes_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = True
        await interaction.response.edit_message(content="Confirmed. Processing...", view=None)
        self.stop()
        
    @discord.ui.button(label="No", style=discord.ButtonStyle.secondary)
    async def no_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = False
        await interaction.response.edit_message(content="Action cancelled.", view=None)
        self.stop()

async def setup(bot: commands.Bot):
    """Set up the CommandManagerCog."""
    await bot.add_cog(CommandManagerCog(bot))
    logger.info("CommandManagerCog loaded")